# 设计思路文档

## 一、产品设计思路

### 1.1 用户画像

**目标用户**：
- 有大量文件需要整理的普通用户
- 需要处理视频的内容创作者
- 对工具有一定要求的技术人员

**用户痛点**：
- 文件夹混乱，不知道有哪些类型的文件
- 重复文件占用空间，手动查找费时
- 视频剪辑软件太重，只想简单截取片段
- 老视频模糊，想提升清晰度

### 1.2 设计原则

```
┌─────────────────────────────────────────────────────────┐
│                      设计原则                            │
├─────────────────────────────────────────────────────────┤
│  1. 简单直接                                             │
│     - 一个功能一个页面                                    │
│     - 操作步骤最少化                                      │
│     - 拖拽优先，点击其次                                  │
├─────────────────────────────────────────────────────────┤
│  2. 安全可控                                             │
│     - 删除操作必须确认                                    │
│     - 提供预览和撤销                                      │
│     - 默认保守策略                                        │
├─────────────────────────────────────────────────────────┤
│  3. 反馈及时                                             │
│     - 长操作显示进度                                      │
│     - 操作结果明确提示                                    │
│     - 错误信息可理解                                      │
├─────────────────────────────────────────────────────────┤
│  4. 性能优先                                             │
│     - 大文件流式处理                                      │
│     - 耗时操作异步执行                                    │
│     - 界面保持响应                                        │
└─────────────────────────────────────────────────────────┘
```

## 二、功能设计思路

### 2.1 文件统计

**设计目标**：让用户快速了解文件夹内容构成

**交互流程**：
```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   拖入文件夹  │ ──▶ │   扫描中...   │ ──▶ │   展示结果    │
│   或点击选择  │     │   显示进度    │     │   表格+图表   │
└──────────────┘     └──────────────┘     └──────────────┘
```

**关键设计决策**：

1. **为什么用表格而不是图表？**
   - 表格信息密度高，一眼看到所有类型
   - 支持排序（按数量/大小）
   - 可以后续扩展（点击类型筛选文件）

2. **为什么显示扫描进度？**
   - 大文件夹扫描可能需要几秒
   - 进度反馈让用户知道程序在工作
   - 避免用户以为卡死

3. **递归深度要不要限制？**
   - 默认不限制，完整扫描
   - 可选：提供深度限制选项（高级设置）

### 2.2 文件去重

**设计目标**：安全、高效地找出并清理重复文件

**交互流程**：
```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   选择文件夹  │ ──▶ │   扫描重复    │ ──▶ │   展示结果    │ ──▶ │   确认删除    │
│              │     │   两阶段扫描  │     │   分组展示    │     │   二次确认    │
└──────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
```

**关键设计决策**：

1. **为什么用两阶段扫描？**
   ```
   阶段1：按文件大小分组（毫秒级）
          ↓ 只对大小相同的文件
   阶段2：计算 MD5（秒级）
   ```
   - 大小不同的文件不可能重复
   - 避免对所有文件计算 MD5，节省 90%+ 时间

2. **为什么分组展示？**
   - 用户需要知道哪些文件是"同一组"重复
   - 方便用户决定保留哪个、删除哪个
   - 每组可以独立操作

3. **为什么需要"智能选择"？**
   - 用户可能有几十组重复文件
   - 手动勾选太累
   - 智能策略：保留最早创建的 / 路径最短的

4. **为什么必须二次确认？**
   - 删除是不可逆操作
   - 防止误删
   - 显示即将删除的文件数量和释放空间

5. **要不要支持"移动到回收站"？**
   - 是的，作为默认选项
   - 给用户后悔的机会
   - 可选"彻底删除"（高级选项）

### 2.3 视频截取

**设计目标**：最简单的方式截取视频片段

**交互流程**：
```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   选择视频    │ ──▶ │   预览视频    │ ──▶ │   设置时间    │ ──▶ │   导出片段    │
│              │     │   显示时长    │     │   开始/结束   │     │   选择位置    │
└──────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
```

**关键设计决策**：

1. **时间输入方式**
   ```
   方案A：滑块选择（直观但不精确）
   方案B：输入框（精确但不直观）
   方案C：滑块 + 输入框（推荐）
   ```
   - 采用方案C，兼顾直观和精确
   - 滑块快速定位，输入框微调

2. **为什么用 `-c copy` 无损截取？**
   - 速度快（几乎瞬间完成）
   - 不损失画质
   - 缺点：起止点可能不精确（关键帧限制）
   - 可选：提供"精确截取"模式（重新编码，慢但精确）

3. **预览功能**
   - 使用 HTML5 `<video>` 标签预览
   - 支持跳转到指定时间点
   - 截取前可以预览起止点画面

### 2.4 视频超分

**设计目标**：一键提升视频清晰度

**交互流程**：
```
┌──────────────┐     ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   选择视频    │ ──▶ │   选择倍数    │ ──▶ │   处理中...   │ ──▶ │   完成提示    │
│              │     │   2x / 4x    │     │   显示进度    │     │   打开文件    │
└──────────────┘     └──────────────┘     └──────────────┘     └──────────────┘
```

**关键设计决策**：

1. **为什么只提供 2x 和 4x？**
   - 覆盖 90% 使用场景
   - 选项太多增加决策成本
   - 4x 以上效果提升有限，时间成倍增加

2. **处理流程设计**
   ```
   视频 → 拆帧 → 逐帧超分 → 合成视频 → 合并音轨
   ```
   - 为什么要拆帧？Real-ESRGAN 只能处理图片
   - 为什么要合并音轨？超分只处理画面，音频需要保留

3. **进度显示**
   - 显示当前阶段（拆帧/超分/合成）
   - 显示处理进度（已处理帧数/总帧数）
   - 显示预估剩余时间

4. **性能预期管理**
   - 明确告知用户处理时间（1分钟视频约需10-30分钟）
   - 建议先用短视频测试效果
   - 提供"取消"按钮

## 三、UI/UX 设计思路

### 3.1 整体布局

```
┌─────────────────────────────────────────────────────────┐
│  📁 File Toolkit                           ─  □  ×     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐           │
│  │📊 统计  │ │🔍 去重  │ │✂️ 截取  │ │✨ 超分  │           │
│  └────────┘ └────────┘ └────────┘ └────────┘           │
│                                                         │
│  ┌─────────────────────────────────────────────────┐   │
│  │                                                 │   │
│  │                  功能区域                        │   │
│  │                                                 │   │
│  └─────────────────────────────────────────────────┘   │
│                                                         │
│  ┌─────────────────────────────────────────────────┐   │
│  │                  结果/操作区域                    │   │
│  └─────────────────────────────────────────────────┘   │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**设计理由**：
- 顶部 Tab 切换功能，一目了然
- 每个功能独立页面，互不干扰
- 上方输入/操作，下方展示结果

### 3.2 拖拽区域设计

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│                         📁                              │
│                                                         │
│              拖入文件夹 或 点击选择                       │
│                                                         │
│         支持递归扫描所有子文件夹                          │
│                                                         │
└─────────────────────────────────────────────────────────┘
     │                                              │
     │  拖入时                                       │
     ▼                                              │
┌─────────────────────────────────────────────────────────┐
│  ┌───────────────────────────────────────────────────┐ │
│  │                      📁                           │ │
│  │                                                   │ │
│  │                 释放以选择                         │ │
│  │                                                   │ │
│  └───────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
        边框变色 + 背景变色，提示可以释放
```

### 3.3 进度反馈设计

**短操作（< 1秒）**：
- 按钮显示 loading 状态
- 不需要进度条

**中等操作（1-10秒）**：
- 显示不确定进度条（循环动画）
- 显示"处理中..."文字

**长操作（> 10秒）**：
- 显示确定进度条（百分比）
- 显示当前阶段
- 显示预估剩余时间
- 提供取消按钮

### 3.4 错误处理设计

```
错误类型              展示方式
─────────────────────────────────────
用户操作错误          Toast 提示，3秒消失
文件不存在            弹窗提示，需要确认
权限不足              弹窗提示 + 引导解决
程序内部错误          弹窗提示 + 错误详情（可展开）
```

## 四、技术设计思路

### 4.1 前后端通信

**为什么用 Tauri IPC 而不是 HTTP？**
- IPC 更轻量，无需启动 HTTP 服务
- 类型安全，Rust 和 TS 类型可以对应
- Tauri 原生支持，无需额外配置

**通信模式**：
```
1. 请求-响应（同步结果）
   前端 invoke() ──▶ Rust 处理 ──▶ 返回结果

2. 事件推送（异步进度）
   Rust window.emit() ──▶ 前端 listen()
```

### 4.2 文件处理策略

**大文件处理**：
```rust
// ❌ 错误：一次性读取整个文件
let content = fs::read(path)?;
let hash = md5::compute(&content);

// ✅ 正确：流式读取
let mut file = File::open(path)?;
let mut hasher = Md5::new();
let mut buffer = [0u8; 65536];
loop {
    let n = file.read(&mut buffer)?;
    if n == 0 { break; }
    hasher.update(&buffer[..n]);
}
```

**并行处理**：
```rust
// 使用 rayon 并行计算多个文件的 MD5
use rayon::prelude::*;

let hashes: Vec<_> = files
    .par_iter()
    .map(|f| calculate_md5(f))
    .collect();
```

### 4.3 视频处理策略

**FFmpeg 调用方式**：
```rust
// 使用 std::process::Command
let output = Command::new("ffmpeg")
    .args(&["-i", input, "-ss", start, "-t", duration, "-c", "copy", output])
    .output()?;
```

**进度获取**：
```rust
// FFmpeg 输出进度到 stderr
// 解析类似 "frame= 1234 fps=30 ..." 的输出
let stderr = String::from_utf8_lossy(&output.stderr);
// 解析并发送进度事件
```

### 4.4 状态管理策略

**前端状态**：
```typescript
// 简单场景：useState
const [files, setFiles] = useState<FileInfo[]>([]);

// 跨组件共享：useContext
const AppContext = createContext<AppState>(null);

// 复杂场景：Zustand（按需引入）
const useStore = create((set) => ({
  files: [],
  setFiles: (files) => set({ files }),
}));
```

**为什么不用 Redux？**
- 本项目状态简单，页面间独立
- Redux 样板代码多，过度设计
- useState + useContext 足够

## 五、扩展性设计

### 5.1 功能扩展

预留扩展点：
```
file-toolkit/
├── src/pages/
│   ├── FileStats.tsx      # 现有
│   ├── Dedup.tsx          # 现有
│   ├── VideoCut.tsx       # 现有
│   ├── VideoUpscale.tsx   # 现有
│   ├── ImageCompress.tsx  # 未来：图片压缩
│   ├── BatchRename.tsx    # 未来：批量重命名
│   └── ...
```

### 5.2 插件化设计（未来）

```typescript
// 插件接口
interface Plugin {
  name: string;
  icon: string;
  component: React.FC;
  commands: TauriCommand[];
}

// 注册插件
registerPlugin({
  name: '图片压缩',
  icon: '🖼️',
  component: ImageCompress,
  commands: ['compress_image'],
});
```

### 5.3 配置系统

```typescript
// 用户可配置项
interface Config {
  // 通用
  theme: 'light' | 'dark' | 'system';
  language: 'zh-CN' | 'en-US';
  
  // 文件去重
  dedup: {
    deleteToTrash: boolean;      // 删除到回收站
    autoSelectStrategy: 'oldest' | 'shortest_path';
  };
  
  // 视频处理
  video: {
    defaultOutputDir: string;    // 默认输出目录
    ffmpegPath?: string;         // 自定义 FFmpeg 路径
  };
}
```

## 六、设计决策记录

| 决策 | 选项 | 最终选择 | 理由 |
|------|------|---------|------|
| 桌面框架 | Electron / Tauri | Tauri | 性能、包体积 |
| 前端框架 | React / Vue | React | 生态、熟悉度 |
| 样式方案 | Tailwind / CSS Modules | Tailwind | 开发效率 |
| 状态管理 | Redux / Zustand / useState | useState | 简单够用 |
| MD5 算法 | 完整文件 / 部分采样 | 完整文件 | 准确性 |
| 删除策略 | 直接删除 / 回收站 | 回收站（默认） | 安全性 |
| FFmpeg 集成 | 内置 / 系统依赖 | 内置 | 开箱即用 |
